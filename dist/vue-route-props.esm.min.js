const t="object"==typeof process&&"object"==typeof process.env&&"production"!==process.env.NODE_ENV,o=(t,o)=>{console.error("[VueRouteProps warn]: ",t,o)},e=t=>({}.toString.call(t)),r=(t,o)=>t.hasOwnProperty(o),n=[null,Boolean,String,Number,Array,Object];function u(){}function i(){return!0}function s(){return{data(){return r(this.$options,"routeProps")&&(t&&function({routeProps:t,context:o}){let r=!0;if("[object Object]"===e(t))for(const n in t)"[object Object]"===e(t[n])&&(r=r&&p({routeProps:t,prop:n,context:o}))}({routeProps:this.$options.routeProps,context:this}),this.$options.routeProps=function({routeProps:t}){if("[object Array]"===e(t)){const o={};for(const e of t)o[e]={};t=o}for(const o in t)"[object Array]"===e(t[o])?t[o]={type:t[o]}:"[object Object]"!==e(t[o])&&(t[o]={type:[t[o]]});for(const o in t){if(!1===r(t[o],"required")&&(t[o].required=!1),!1===r(t[o],"type")?t[o].type=n:"[object Array]"!==e(t[o].type)?t[o].type=[t[o].type]:0===t[o].type.length&&(t[o].type=n),!1===r(t[o],"default"))t[o].default=u;else if("[object Function]"!==e(t[o].default)){const e=t[o].default;t[o].default=function(){return e}}!1===r(t[o],"validator")&&(t[o].validator=i)}return t}({routeProps:this.$options.routeProps}),this._routeProps={}),{}},watch:{$route:{immediate:!0,handler(){if(!1===r(this.$options,"routeProps"))return;t&&function({normalizedRouteProps:t,context:o}){let e=!0;for(const r in t)e=e&&c({normalizedRouteProps:t,prop:r,context:o})&&a({normalizedRouteProps:t,prop:r,context:o})&&l({normalizedRouteProps:t,prop:r,context:o})}({normalizedRouteProps:this.$options.routeProps,context:this});const e=function({normalizedRouteProps:t,route:o,context:e}){const n={};for(const e in t)n[e]=r(o.query,e)?JSON.parse(o.query[e]):t[e].default();return n}({normalizedRouteProps:this.$options.routeProps,route:this.$route,context:this});for(const t in e)this._routeProps[t]=e[t],Object.defineProperty(this,t,{configurable:!0,enumerable:!0,set(e){o("Avoid mutating a routeProp directly since the value will be overwritten whenever the route changes. Instead, use a data or computed property based on the routeProp's "+`value. Prop being mutated: "${t}"`,this)},get(){return this._routeProps[t]}})}}}}}function p({routeProps:t,prop:r,context:n}){return"[object Object]"!==e(t[r].default)&&"[object Array]"!==e(t[r].default)||(o(`Invalid default value for routeProp "${r}": routeProps with type Object/Array must use a factory function to return the default value.`,n),!1)}function c({normalizedRouteProps:t,prop:e,context:n}){const u=r(n.$route.query,e)?JSON.parse(n.$route.query[e]):void 0;return!t[e].required||void 0!==u||(o(`Missing required routeProp: "${e}"`,n),!1)}function a({normalizedRouteProps:t,prop:n,context:u}){const i=r(u.$route.query,n)?JSON.parse(u.$route.query[n]):t[n].default();let s=!0;if(void 0===i?!0===t[n].required&&(s=!1):null===i?!1===t[n].type.includes(null)&&(s=!1):!1===t[n].type.includes(Object.getPrototypeOf(i).constructor)&&(s=!1),!1===s){const r=[];for(const o of t[n].type)null===o?r.push("null"):r.push(/function ([^(]+)/.exec(o.toString())[1]);const s=e(i).slice(8,-1);o(`Invalid routeProp: type check failed for routeProp "${n}". Expected ${r.join(", ")}, got ${s} with value ${JSON.stringify(i)}.`,u)}return s}function l({normalizedRouteProps:t,prop:e,context:n}){const u=r(n.$route.query,e)?JSON.parse(n.$route.query[e]):t[e].default();return!!t[e].validator(u,e)||(o(`Invalid routeProp: custom validator check failed for routeProp "${e}".`,n),!1)}var f={install:function(t){t.mixin(s())}};export default f;

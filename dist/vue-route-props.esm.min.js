import t from"vue";const o="object"==typeof process&&"object"==typeof process.env&&"production"!==process.env.NODE_ENV,e=(t,o)=>{console.error("[VueRouteProps warn]: ",t,o)},r=t=>({}.toString.call(t)),n=(t,o)=>t.hasOwnProperty(o),u=[null,Boolean,String,Number,Array,Object];function i(){}function s(){return!0}function p(){return{beforeCreate(){if(void 0===this.$options.routeProps)return{};o&&function({routeProps:t,context:o}){let e=!0;if("[object Object]"===r(t))for(const n in t)"[object Object]"===r(t[n])&&(e=e&&c({routeProps:t,prop:n,context:o}))}({routeProps:this.$options.routeProps,context:this}),this._routeProps={normalized:a({routeProps:this.$options.routeProps}),computed:{}};for(const o in this._routeProps.normalized)this._routeProps.computed[o]=void 0,t.util.defineReactive(this._routeProps.computed,o),P({vm:this,routeProp:o})},watch:{$route:{immediate:!0,handler(){if(void 0===this.$options.routeProps)return;o&&function({normalizedRouteProps:t,context:o}){let e=!0;for(const r in t)e=e&&l({normalizedRouteProps:t,prop:r,context:o})&&d({normalizedRouteProps:t,prop:r,context:o})&&f({normalizedRouteProps:t,prop:r,context:o})}({normalizedRouteProps:this._routeProps.normalized,context:this});const t=function({normalizedRouteProps:t,route:o,context:e}){const r={};for(const e in t)r[e]=n(o.query,e)?JSON.parse(o.query[e]):t[e].default();return r}({normalizedRouteProps:this._routeProps.normalized,route:this.$route,context:this});for(const o in t)this._routeProps.computed[o]=t[o]}}}}}function c({routeProps:t,prop:o,context:n}){return"[object Object]"!==r(t[o].default)&&"[object Array]"!==r(t[o].default)||(e(`Invalid default value for routeProp "${o}": routeProps with type Object/Array must use a factory function to return the default value.`,n),!1)}function a({routeProps:t}){if("[object Array]"===r(t)){const o={};for(const e of t)o[e]={};t=o}for(const o in t)"[object Array]"===r(t[o])?t[o]={type:t[o]}:"[object Object]"!==r(t[o])&&(t[o]={type:[t[o]]});for(const o in t){if(!1===n(t[o],"required")&&(t[o].required=!1),!1===n(t[o],"type")?t[o].type=u:"[object Array]"!==r(t[o].type)?t[o].type=[t[o].type]:0===t[o].type.length&&(t[o].type=u),!1===n(t[o],"default"))t[o].default=i;else if("[object Function]"!==r(t[o].default)){const e=t[o].default;t[o].default=function(){return e}}!1===n(t[o],"validator")&&(t[o].validator=s)}return t}function l({normalizedRouteProps:t,prop:o,context:r}){const u=n(r.$route.query,o)?JSON.parse(r.$route.query[o]):void 0;return!t[o].required||void 0!==u||(e(`Missing required routeProp: "${o}"`,r),!1)}function d({normalizedRouteProps:t,prop:o,context:u}){const i=n(u.$route.query,o)?JSON.parse(u.$route.query[o]):t[o].default();let s=!0;if(void 0===i?!0===t[o].required&&(s=!1):null===i?!1===t[o].type.includes(null)&&(s=!1):!1===t[o].type.includes(Object.getPrototypeOf(i).constructor)&&(s=!1),!1===s){const n=[];for(const e of t[o].type)null===e?n.push("null"):n.push(/function ([^(]+)/.exec(e.toString())[1]);const s=r(i).slice(8,-1);e(`Invalid routeProp: type check failed for routeProp "${o}". Expected ${n.join(", ")}, got ${s} with value ${JSON.stringify(i)}.`,u)}return s}function f({normalizedRouteProps:t,prop:o,context:r}){const u=n(r.$route.query,o)?JSON.parse(r.$route.query[o]):t[o].default();return!(t[o].required&&!t[o].validator(u,o))||(e(`Invalid routeProp: custom validator check failed for routeProp "${o}".`,r),!1)}function P({vm:t,routeProp:o}){Object.defineProperty(t,o,{configurable:!0,enumerable:!0,set(){e("Avoid mutating a routeProp directly since the value will be overwritten whenever the route changes. Instead, use a data or computed property based on the routeProp's "+`value. Prop being mutated: "${o}"`,t)},get:()=>t._routeProps.computed[o]})}var y={install:function(t){t.mixin(p())}};export default y;

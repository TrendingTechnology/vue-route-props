!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("vue")):"function"==typeof define&&define.amd?define(["vue"],t):(e=e||self).VueChronos=t(e.Vue)}(this,(function(e){"use strict";e=e&&e.hasOwnProperty("default")?e.default:e;const t="object"==typeof process&&"object"==typeof process.env&&"production"!==process.env.NODE_ENV,o=(e,t)=>{console.error("[VueRouteProps warn]: ",e,t)},r=e=>({}.toString.call(e)),n=(e,t)=>e.hasOwnProperty(t),u=[null,Boolean,String,Number,Array,Object];function i(){}function s(){return!0}function c(){return{beforeCreate(){if(void 0===this.$options.routeProps)return{};t&&function({routeProps:e,context:t}){let o=!0;if("[object Object]"===r(e))for(const n in e)"[object Object]"===r(e[n])&&(o=o&&p({routeProps:e,prop:n,context:t}))}({routeProps:this.$options.routeProps,context:this}),this._routeProps={normalized:a({routeProps:this.$options.routeProps}),computed:{}};for(const t in this._routeProps.normalized)this._routeProps.computed[t]=void 0,e.util.defineReactive(this._routeProps.computed,t),P({vm:this,routeProp:t})},watch:{$route:{immediate:!0,handler(){if(void 0===this.$options.routeProps)return;t&&function({normalizedRouteProps:e,context:t}){let o=!0;for(const r in e)o=o&&d({normalizedRouteProps:e,prop:r,context:t})&&l({normalizedRouteProps:e,prop:r,context:t})&&f({normalizedRouteProps:e,prop:r,context:t})}({normalizedRouteProps:this._routeProps.normalized,context:this});const e=function({normalizedRouteProps:e,route:t,context:o}){const r={};for(const o in e)r[o]=n(t.query,o)?JSON.parse(t.query[o]):e[o].default();return r}({normalizedRouteProps:this._routeProps.normalized,route:this.$route,context:this});for(const t in e)this._routeProps.computed[t]=e[t]}}}}}function p({routeProps:e,prop:t,context:n}){return"[object Object]"!==r(e[t].default)&&"[object Array]"!==r(e[t].default)||(o(`Invalid default value for routeProp "${t}": routeProps with type Object/Array must use a factory function to return the default value.`,n),!1)}function a({routeProps:e}){if("[object Array]"===r(e)){const t={};for(const o of e)t[o]={};e=t}for(const t in e)"[object Array]"===r(e[t])?e[t]={type:e[t]}:"[object Object]"!==r(e[t])&&(e[t]={type:[e[t]]});for(const t in e){if(!1===n(e[t],"required")&&(e[t].required=!1),!1===n(e[t],"type")?e[t].type=u:"[object Array]"!==r(e[t].type)?e[t].type=[e[t].type]:0===e[t].type.length&&(e[t].type=u),!1===n(e[t],"default"))e[t].default=i;else if("[object Function]"!==r(e[t].default)){const o=e[t].default;e[t].default=function(){return o}}!1===n(e[t],"validator")&&(e[t].validator=s)}return e}function d({normalizedRouteProps:e,prop:t,context:r}){const u=n(r.$route.query,t)?JSON.parse(r.$route.query[t]):void 0;return!e[t].required||void 0!==u||(o(`Missing required routeProp: "${t}"`,r),!1)}function l({normalizedRouteProps:e,prop:t,context:u}){const i=n(u.$route.query,t)?JSON.parse(u.$route.query[t]):e[t].default();let s=!0;if(void 0===i?!0===e[t].required&&(s=!1):null===i?!1===e[t].type.includes(null)&&(s=!1):!1===e[t].type.includes(Object.getPrototypeOf(i).constructor)&&(s=!1),!1===s){const n=[];for(const o of e[t].type)null===o?n.push("null"):n.push(/function ([^(]+)/.exec(o.toString())[1]);const s=r(i).slice(8,-1);o(`Invalid routeProp: type check failed for routeProp "${t}". Expected ${n.join(", ")}, got ${s} with value ${JSON.stringify(i)}.`,u)}return s}function f({normalizedRouteProps:e,prop:t,context:r}){const u=n(r.$route.query,t)?JSON.parse(r.$route.query[t]):e[t].default();return!(e[t].required&&!e[t].validator(u,t))||(o(`Invalid routeProp: custom validator check failed for routeProp "${t}".`,r),!1)}function P({vm:e,routeProp:t}){Object.defineProperty(e,t,{configurable:!0,enumerable:!0,set(){o("Avoid mutating a routeProp directly since the value will be overwritten whenever the route changes. Instead, use a data or computed property based on the routeProp's "+`value. Prop being mutated: "${t}"`,e)},get:()=>e._routeProps.computed[t]})}return{install:function(e){e.mixin(c())}}}));

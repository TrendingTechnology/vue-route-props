"use strict";var t,e=(t=require("vue"))&&"object"==typeof t&&"default"in t?t.default:t;const o="object"==typeof process&&"object"==typeof process.env&&"production"!==process.env.NODE_ENV,r=(t,e)=>{console.error("[VueRouteProps warn]: ",t,e)},n=t=>({}.toString.call(t)),u=(t,e)=>t.hasOwnProperty(e),i=[null,Boolean,String,Number,Array,Object];function s(){}function c(){return!0}function p(){return{beforeCreate(){if(void 0===this.$options.routeProps)return{};o&&function({routeProps:t,context:e}){let o=!0;if("[object Object]"===n(t))for(const r in t)"[object Object]"===n(t[r])&&(o=o&&a({routeProps:t,prop:r,context:e}))}({routeProps:this.$options.routeProps,context:this}),this._routeProps={normalized:l({routeProps:this.$options.routeProps}),computed:{}};for(const t in this._routeProps.normalized)this._routeProps.computed[t]=void 0,e.util.defineReactive(this._routeProps.computed,t),y({vm:this,routeProp:t})},watch:{$route:{immediate:!0,handler(){if(void 0===this.$options.routeProps)return;o&&function({normalizedRouteProps:t,context:e}){let o=!0;for(const r in t)o=o&&d({normalizedRouteProps:t,prop:r,context:e})&&f({normalizedRouteProps:t,prop:r,context:e})&&P({normalizedRouteProps:t,prop:r,context:e})}({normalizedRouteProps:this._routeProps.normalized,context:this});const t=function({normalizedRouteProps:t,route:e,context:o}){const r={};for(const o in t)r[o]=u(e.query,o)?JSON.parse(e.query[o]):t[o].default();return r}({normalizedRouteProps:this._routeProps.normalized,route:this.$route,context:this});for(const e in t)this._routeProps.computed[e]=t[e]}}}}}function a({routeProps:t,prop:e,context:o}){return"[object Object]"!==n(t[e].default)&&"[object Array]"!==n(t[e].default)||(r(`Invalid default value for routeProp "${e}": routeProps with type Object/Array must use a factory function to return the default value.`,o),!1)}function l({routeProps:t}){if("[object Array]"===n(t)){const e={};for(const o of t)e[o]={};t=e}for(const e in t)"[object Array]"===n(t[e])?t[e]={type:t[e]}:"[object Object]"!==n(t[e])&&(t[e]={type:[t[e]]});for(const e in t){if(!1===u(t[e],"required")&&(t[e].required=!1),!1===u(t[e],"type")?t[e].type=i:"[object Array]"!==n(t[e].type)?t[e].type=[t[e].type]:0===t[e].type.length&&(t[e].type=i),!1===u(t[e],"default"))t[e].default=s;else if("[object Function]"!==n(t[e].default)){const o=t[e].default;t[e].default=function(){return o}}!1===u(t[e],"validator")&&(t[e].validator=c)}return t}function d({normalizedRouteProps:t,prop:e,context:o}){const n=u(o.$route.query,e)?JSON.parse(o.$route.query[e]):void 0;return!t[e].required||void 0!==n||(r(`Missing required routeProp: "${e}"`,o),!1)}function f({normalizedRouteProps:t,prop:e,context:o}){const i=u(o.$route.query,e)?JSON.parse(o.$route.query[e]):t[e].default();let s=!0;if(void 0===i?!0===t[e].required&&(s=!1):null===i?!1===t[e].type.includes(null)&&(s=!1):!1===t[e].type.includes(Object.getPrototypeOf(i).constructor)&&(s=!1),!1===s){const u=[];for(const o of t[e].type)null===o?u.push("null"):u.push(/function ([^(]+)/.exec(o.toString())[1]);const s=n(i).slice(8,-1);r(`Invalid routeProp: type check failed for routeProp "${e}". Expected ${u.join(", ")}, got ${s} with value ${JSON.stringify(i)}.`,o)}return s}function P({normalizedRouteProps:t,prop:e,context:o}){const n=u(o.$route.query,e)?JSON.parse(o.$route.query[e]):t[e].default();return!(t[e].required&&!t[e].validator(n,e))||(r(`Invalid routeProp: custom validator check failed for routeProp "${e}".`,o),!1)}function y({vm:t,routeProp:e}){Object.defineProperty(t,e,{configurable:!0,enumerable:!0,set(){r("Avoid mutating a routeProp directly since the value will be overwritten whenever the route changes. Instead, use a data or computed property based on the routeProp's "+`value. Prop being mutated: "${e}"`,t)},get:()=>t._routeProps.computed[e]})}var h={install:function(t){t.mixin(p())}};module.exports=h;

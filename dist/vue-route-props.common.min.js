"use strict";require("vue");const t="object"==typeof process&&"object"==typeof process.env&&"production"!==process.env.NODE_ENV,o=(t,o)=>{console.error("[VueRouteProps warn]: ",t,o)},e=t=>({}.toString.call(t)),r=(t,o)=>t.hasOwnProperty(o),u=[null,Boolean,String,Number,Array,Object];function n(){}function i(){return!0}function s(u,n={}){return{beforeCreate(){if(void 0!==this.$options.routeProps){t&&(function({context:t}){void 0===t.$router&&o("Missing vue-router",t)}({context:this}),function({routeProps:t,context:o}){let r=!0;if("[object Object]"===e(t))for(const u in t)"[object Object]"===e(t[u])&&(r=r&&c({routeProps:t,prop:u,context:o})&&p({routeProps:t,prop:u,context:o}))}({routeProps:this.$options.routeProps,context:this})),this._routeProps={normalized:a({routeProps:this.$options.routeProps}),computed:{}};for(const t in this._routeProps.normalized)this._routeProps.computed[t]=void 0,u.util.defineReactive(this._routeProps.computed,t),P({vm:this,routeProp:t})}},watch:{$route:{immediate:!0,handler(){if(void 0===this.$options.routeProps)return;t&&function({normalizedRouteProps:t,context:o}){let e=!0;for(const r in t)e=e&&l({normalizedRouteProps:t,prop:r,context:o})&&d({normalizedRouteProps:t,prop:r,context:o})&&f({normalizedRouteProps:t,prop:r,context:o})}({normalizedRouteProps:this._routeProps.normalized,context:this});const o=function({normalizedRouteProps:t,route:o,context:e}){const u={};for(const e in t)u[e]=r(o.query,e)?JSON.parse(o.query[e]):t[e].default();return u}({normalizedRouteProps:this._routeProps.normalized,route:this.$route,context:this});for(const t in o)this._routeProps.computed[t]=o[t];var e,u;n.inspect&&(e=JSON.stringify(this._routeProps.computed,null,2),u=this,console.log("[VueRouteProps log]: ",e,u))}}}}}function c({routeProps:t,prop:r,context:u}){return"[object Object]"!==e(t[r].default)&&"[object Array]"!==e(t[r].default)||(o(`Invalid default value for routeProp "${r}": routeProps with type Object/Array must use a factory function to return the default value.`,u),!1)}function p({routeProps:t,prop:u,context:n}){let i=!0;return"[object Function]"===e(t[u].validator)&&r(t[u],"default")&&(i="[object Function]"===e(t[u].default)?t[u].validator(t[u].default()):t[u].validator(t[u].default)),!1===i&&o(`Invalid routeProp: custom validator check failed for routeProp "${u}".`,n),i}function a({routeProps:t}){if("[object Array]"===e(t)){const o={};for(const e of t)o[e]={};t=o}for(const o in t)"[object Array]"===e(t[o])?t[o]={type:t[o]}:"[object Object]"!==e(t[o])&&(t[o]={type:[t[o]]});for(const o in t){if(!1===r(t[o],"required")&&(t[o].required=!1),!1===r(t[o],"type")?t[o].type=u:"[object Array]"!==e(t[o].type)?t[o].type=[t[o].type]:0===t[o].type.length&&(t[o].type=u),!1===r(t[o],"default"))t[o].default=n;else if("[object Function]"!==e(t[o].default)){const e=t[o].default;t[o].default=function(){return e}}!1===r(t[o],"validator")&&(t[o].validator=i)}return t}function l({normalizedRouteProps:t,prop:e,context:u}){const n=r(u.$route.query,e)?JSON.parse(u.$route.query[e]):void 0;return!t[e].required||void 0!==n||(o(`Missing required routeProp: "${e}"`,u),!1)}function d({normalizedRouteProps:t,prop:u,context:n}){const i=r(n.$route.query,u)?JSON.parse(n.$route.query[u]):t[u].default();let s=!0;if(void 0===i?!0===t[u].required&&(s=!1):null===i?!1===t[u].type.includes(null)&&(s=!1):!1===t[u].type.includes(Object.getPrototypeOf(i).constructor)&&(s=!1),!1===s){const r=[];for(const o of t[u].type)null===o?r.push("null"):r.push(/function ([^(]+)/.exec(o.toString())[1]);const s=e(i).slice(8,-1);o(`Invalid routeProp: type check failed for routeProp "${u}". Expected ${r.join(", ")}, got ${s} with value ${JSON.stringify(i)}.`,n)}return s}function f({normalizedRouteProps:t,prop:e,context:u}){const n=r(u.$route.query,e)?JSON.parse(u.$route.query[e]):t[e].default();return!((t[e].required||r(u.$route.query,e))&&!t[e].validator(n,e))||(o(`Invalid routeProp: custom validator check failed for routeProp "${e}".`,u),!1)}function P({vm:t,routeProp:e}){Object.defineProperty(t,e,{configurable:!0,enumerable:!0,set(){o("Avoid mutating a routeProp directly since the value will be overwritten whenever the route changes. Instead, use a data or computed property based on the routeProp's "+`value. Prop being mutated: "${e}"`,t)},get:()=>t._routeProps.computed[e]})}var y={install:function(t,o){t.mixin(s(t,o))}};module.exports=y;
